{
  "hash": "13d1cea3791c93db7bf0eeeb0732a506",
  "result": {
    "engine": "jupyter",
    "markdown": "/*1) Find maximal departure delay in minutes for each airline. Sort results from smallest to largest maximum\ndelay. Output airline names and values of the delay.*/\n\n```{sql}\nselect b.Name, max(a.DepDelayMinutes) as max_dep_delay\nfrom al_perf a \njoin L_AIRLINE_ID b \non a.DOT_ID_Reporting_Airline =b.ID\ngroup by b.Name\norder by max_dep_delay;\n#17 rows returned\n```\n\n/*2) Find maximal early departures in minutes for each airline. Sort results from largest to smallest. Output\nairline names.*/\n\n```{sql}\nselect b.Name, min(a.DepDelay) as max_dep_early\nfrom al_perf a \njoin L_AIRLINE_ID b \non a.DOT_ID_Reporting_Airline =b.ID\nwhere a.DepDelay<0\ngroup by b.Name\norder by max_dep_early;\n#17 rows returned\n```\n\n/*3)Rank days of the week by the number of flights performed by all airlines on that day (1 is the busiest).\nOutput the day of the week names, number of flights and ranks in the rank increasing order.*/\n\n```{sql}\nselect w.Day as DayName, sum(a.Flights) as NumFlights, dense_rank() over (order by sum(a.Flights) desc) as rnk\nfrom al_perf a\njoin L_WEEKDAYS w\n    on a.DayOfWeek = w.Code\ngroup by w.Day\norder by rnk;\n#7 rows returned\n```\n\n/*4) Find the airport that has the highest average departure delay among all airports. Consider 0 minutes delay\nfor flights that departed early. Output one line of results: the airport name, code, and average delay.*/\n\n```{sql}\nselect a2.Name as AirportName, a1.Code as AirportCode, avg(greatest(p.DepDelay, 0)) as AvgDepartureDelay\nfrom al_perf p\njoin L_AIRPORT_ID a2 on p.OriginAirportID = a2.ID\njoin L_AIRPORT a1 on a1.Name = a2.Name       \ngroup by a2.Name, a1.Code\norder by AvgDepartureDelay desc\nlimit 1;\n# 1 row returned\n```\n\n/*5) For each airline find an airport where it has the highest average departure delay. Output an airline name, a\nname of the airport that has the highest average delay, and the value of that average delay.*/\n\n```{sql}\nwith avg_delay as (\n    select c.Name as AirlineName, b.Name as AirportName, avg(greatest(a.DepDelay, 0)) as AvgDelay\n    from al_perf a\n    join L_AIRPORT_ID b on a.OriginAirportID = b.ID\n    join L_AIRLINE_ID c on a.DOT_ID_Reporting_Airline = c.ID\n    group by c.Name, b.Name\n),\nranked as (\n    select AirlineName, AirportName, AvgDelay,row_number() over (partition by AirlineName order by AvgDelay desc) as rn\n    from avg_delay\n)\nselect AirlineName, AirportName, AvgDelay\nfrom ranked\nwhere rn = 1\norder by AirlineName;\n#17 rows returned\n```\n\n```{sql}\n/*6a) Check if your dataset has any canceled flights.*/\nselect count(*) as NumCanceledFlights\nfrom al_perf\nwhere Cancelled = 1\n#1 row returned\n\n/*6b) If it does, what was the most frequent reason for each departure airport? Output airport name,\nthe most frequent reason, and the number of cancelations for that reason.*/\nwith cancel_counts as (\n    select ap.Name as AirportName, r.Reason as CancelReason, count(*) as NumCancel\n    from al_perf a\n    join L_AIRPORT_ID ap on a.OriginAirportID = ap.ID\n    join L_CANCELATION r on a.CancellationCode = r.Code\n    where a.Cancelled = 1\n    group by ap.Name, r.Reason\n),\nranked as (\n    select AirportName, CancelReason, NumCancel,\n        row_number() over (partition by AirportName order by NumCancel desc) as rn\n    from cancel_counts\n)\nselect AirportName, CancelReason, NumCancel\nfrom ranked\nwhere rn = 1\norder by AirportName;\n#265 rows returned\n```\n\n/*7) Build a report that for each day output average number of flights over the preceding 3 days.*/\n\n```{sql}\nwith daily_flights as (\n    select cast(FlightDate as date) as FlightDate,sum(Flights) as NumFlights\n    from al_perf\n    group by cast(FlightDate as date)\n)\n\nselect FlightDate,NumFlights,avg(NumFlights) over (order by FlightDate rows between 3 preceding and 1 preceding  \n    ) as AvgFlightsPrev3Days\nfrom daily_flights\norder by FlightDate\n#32 rows returned\n```\n\n",
    "supporting": [
      "results_files"
    ],
    "filters": [],
    "includes": {}
  }
}